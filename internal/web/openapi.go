package web

import (
	"context"
	"errors"
	"net/http"
	"strings"

	"fmt"
	"regexp"

	"bitbucket.org/crgw/service-helpers/middleware"
	"bitbucket.org/crgw/supplier-hub/internal/web/spec"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/getkin/kin-openapi/routers"
	"github.com/gin-gonic/gin"
)

func OpenapiValidator() gin.HandlerFunc {
	spec, err := spec.GetSwagger() // auto-generated by oapi-codegen
	if err != nil {
		panic(err)
	}

	err = spec.Validate(context.Background())
	if err != nil {
		panic(err)
	}

	return func(c *gin.Context) {
		if strings.HasPrefix(c.Request.URL.Path, "/debug") {
			return
		}

		err := validateRequest(c, spec, c.Request)

		if err != nil {
			if errors.Is(err, errorPathNotFound) || errors.Is(err, errorOperationNotFound) {
				c.AbortWithStatusJSON(http.StatusNotFound, err.Error())
				return
			}

			middleware.HandleError(c, http.StatusBadRequest, err.Error(), err)
		}
	}
}

var (
	errorPathNotFound      = errors.New("path not found")
	errorOperationNotFound = errors.New("operation not found")
)

func validateRequest(ctx *gin.Context, spec *openapi3.T, request *http.Request) error {
	route, err := findRoute(spec, ctx.FullPath(), request)
	if err != nil {
		return err
	}

	requestValidationInput := &openapi3filter.RequestValidationInput{
		Request:     request,
		PathParams:  normalizeParams(ctx.Params),
		QueryParams: request.URL.Query(),
		Route:       route,
	}

	return openapi3filter.ValidateRequest(ctx, requestValidationInput)
}

func ValidateResponse(ctx *gin.Context, spec *openapi3.T, request *http.Request, responseCode int, responseHeaders http.Header, responseBody []byte) error {
	route, err := findRoute(spec, ctx.FullPath(), request)
	if err != nil {
		return err
	}

	requestValidationInput := &openapi3filter.RequestValidationInput{
		Request:     request,
		PathParams:  normalizeParams(ctx.Params),
		QueryParams: request.URL.Query(),
		Route:       route,
	}

	responseValidationInput := &openapi3filter.ResponseValidationInput{
		RequestValidationInput: requestValidationInput,
		Status:                 responseCode,
		Header:                 responseHeaders,
	}
	responseValidationInput.SetBodyBytes(responseBody)
	return openapi3filter.ValidateResponse(ctx, responseValidationInput)
}

func normalizePath(path string) string {
	re := regexp.MustCompile(`:[a-zA-Z0-9_]+`)

	matches := re.FindAllString(path, -1)

	for _, match := range matches {
		path = regexp.MustCompile(match).ReplaceAllString(path, "{"+match[1:]+"}")
	}

	return path
}

func findRoute(spec *openapi3.T, pathTemplate string, request *http.Request) (*routers.Route, error) {
	pathItem := spec.Paths.Find(normalizePath(pathTemplate))
	if pathItem == nil {
		return nil, fmt.Errorf("%s: %w", pathTemplate, errorPathNotFound)
	}

	operation := pathItem.GetOperation(request.Method)
	if operation == nil {
		return nil, errorOperationNotFound
	}

	return &routers.Route{
		Spec:      spec,
		Server:    nil,
		Path:      request.URL.Path,
		PathItem:  pathItem,
		Method:    request.Method,
		Operation: operation,
	}, nil
}

func normalizeParams(params gin.Params) map[string]string {
	result := make(map[string]string)

	for _, param := range params {
		result[param.Key] = param.Value
	}

	return result
}
